\documentclass[ignorenonframetext,]{beamer}

\usepackage{hyperref}
\usepackage{soul}
\usepackage{minted}
\usepackage{fancyvrb}

\usepackage{tcolorbox}
\usepackage{etoolbox}

\newcommand{\myurl}[1]{\textcolor{blue}{\underline{\url{#1}}}}

\usetheme{Warsaw}
\useoutertheme{infolines} % Display the slides number in the footline (and a smaller header)

% Various settings
\setbeamercovered{transparent} % Just gray covered text in overlays


% Add a tableofcontent slide before each subsection
\AtBeginSubsection{
    \frame{\tableofcontents[currentsubsection]}
}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}


\title{Introduction to Python scripting}
\author{Paul ``Dettorer'' Hervot}
\date{8 November 2014}

\begin{document}
\frame{\titlepage}

\frame{\tableofcontents}

\section{Basics}
\subsection{Meta}

\begin{frame}{Classification}
    \begin{itemize}
        \item Imperative
        \item High level
        \item Interpreted
        \item Object oriented
        \item Functional style is easily doable!
    \end{itemize}
\end{frame}

\begin{frame}{Zen of Python (PEP 20)}

    Python Enhancement Proposal number 20

    \setbeamertemplate{itemize/enumerate body begin}{\tiny}
    \begin{itemize}
        \item<1-1> Beautiful is better than ugly.
        \item<1-2> Explicit is better than implicit.
        \item<1-2> Simple is better than complex.
        \item<1-1> Complex is better than complicated.
        \item<1-1> Flat is better than nested.
        \item<1-1> Sparse is better than dense.
        \item<1-2> Readability counts.
        \item<1-1> Special cases aren't special enough to break the rules.
        \item<1-1> Although practicality beats purity.
        \item<1-2> Errors should never pass silently.
        \item<1-1> Unless explicitly silenced.
        \item<1-1> In the face of ambiguity, refuse the temptation to guess.
        \item<1-2> There should be one -- and preferably only one -- obvious way to do it.
        \item<1-1> Although that way may not be obvious at first unless you're Dutch.
        \item<1-1> Now is better than never.
        \item<1-1> Although never is often better than \emph{right} now.
        \item<1-2> If the implementation is hard to explain, it's a bad idea.
        \item<1-1> If the implementation is easy to explain, it may be a good idea.
        \item<1-2> Namespaces are one honking great idea -- let's do more of those!
    \end{itemize}
\end{frame}

\begin{frame}{Zen of Python (PEP 20)}

    Python Enhancement Proposal number 20

    \begin{itemize}[<+-| alert@+>]
        \item Readability counts.
        \item Explicit is better than implicit.
        \item Simple is better than complex.
        \item Errors should never pass silently (unless explicitly silenced)
        \item There should be one -- and preferably only one -- obvious way to do it.
        \item If the implementation is hard to explain, it's a bad idea.
        \item Namespaces are one honking great idea, let's do more of those!
    \end{itemize}
\end{frame}

\begin{frame}%{Zen of Python (PEP 20)}

    For some examples, see

    \myurl{http://artifex.org/~hblanks/talks/2011/pep20_by_example.html}

\end{frame}

\begin{frame}{Python version}

    This talk is about {\LARGE Python} {\Huge 3}

    When you have the choice, choose Python 3

    Discussion on the subject: \myurl{https://wiki.python.org/moin/Python2orPython3}\\

    What's new in Python 3: \myurl{https://docs.python.org/3/whatsnew/3.0.html}

\end{frame}

\subsection{Syntax}

\begin{frame}[fragile]{Numbers}

    Let's fire up the interactive interpretor!

    \begin{tcolorbox}
    \begin{minted}{python}
>>> 2 + 2
4
>>> 50 - 5 * 6
20
>>> (50 - 5 * 6) / 4 # A division always returns a float
5.0
>>> 8 / 5
1.6
>>> 8 // 5
1
>>> 17 % 3 # Modulo
2
>>> 16 ** 2
256
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Numbers}

    NO MAX\_INT, YES GOOD SIR.

    \begin{tcolorbox}
    \begin{minted}{python}
>>> 1337 ** 42
19838969283201668912802581405118643546980893102725998019
48050412127679244922796488044370956538397425350061200008
19629040274718649969
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Strings}
    \begin{tcolorbox}
    \begin{minted}{python}
>>> 'This parrot is no more!'
'This parrot is no more!'
    \end{minted}
    \end{tcolorbox}

    \pause
    \begin{tcolorbox}
    \begin{minted}{python}
>>> "It has ceased to be!"
'It has ceased to be!'
    \end{minted}
    \end{tcolorbox}

    \pause
    \begin{tcolorbox}
    \begin{minted}{python}
>>> '''It's expired and gone to meet its maker!
... This is a late parrot!'''
"It's expired and gone to meet its maker!\nThis is a\
late parrot!"
    \end{minted}
    \end{tcolorbox}

    \pause
    \begin{tcolorbox}
    \begin{minted}{python}
>>> 'It\'s a stiff!'
"It's a stiff!"
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Strings}
    \begin{tcolorbox}
    \begin{minted}{python}
>>> 'This is an ex-parrot!'.upper()
'THIS IS AN EX-PARROT!'
    \end{minted}
    \end{tcolorbox}

    \pause
    \begin{tcolorbox}
    \begin{minted}{python}
>>> 'A smile, ' + 'two bangs, ' + 'and a religion.'
'A smile, two bangs, and a religion.'
    \end{minted}
    \end{tcolorbox}

    \pause
    \begin{tcolorbox}
    \begin{minted}{python}
>>> 'Gooooood night ' + 'ding' * 5
'Gooooood night dingdingdingdingding'
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{\st{Variables} Names}

    Dynamic typing, duck typing: just think about \emph{names}

    \begin{tcolorbox}
    \begin{minted}{python}
>>> 20
20
>>> width = 20
>>> height = 5 * 9
>>> width * height
900
>>> width = '"largeur" in french'
>>> height = '"hauteur" in french'
>>> width + ' and ' + height
'"largeur" in french and "hauteur" in french'
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{\st{Variables} Names}

    But really. Python is strongly typed

    \begin{tcolorbox}
    \begin{minted}{python}
>>> count = 3
>>> 'Then shalt thou count to ' + count + '.'
    \end{minted}
    \begin{minted}{py3tb}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly
    \end{minted}
    \end{tcolorbox}

    \pause
    In this case, use \emph{format}:
    \begin{tcolorbox}
    \begin{minted}{python}
>>> count = 3
>>> 'Then shalt thou count to {}.'.format(count)
'Then shalt thou count to 3.'
    \end{minted}
    \end{tcolorbox}
\end{frame}

\subsection{Data structures}
\begin{frame}[fragile]{Lists}

    Lists are easy and quick to use.

    \begin{tcolorbox}
    \begin{minted}{python}
>>> nums = [1, 3, 5, 9, 14]
>>> nums
[1, 3, 5, 9, 14]
>>> nums[0]
1
>>> nums[1]
3
>>> nums[-1]
14
>>> nums[1:4]
[3, 5, 9]
>>> nums[1] = 21
>>> nums
[1, 21, 5, 9, 14]
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Lists}

    Adding and removing from a list:

    \begin{tcolorbox}
    \begin{minted}{python}
>>> nums = [1, 3, 5, 9, 14]
>>> nums
[1, 3, 5, 9, 14]
>>> nums.append(24)
>>> nums
[1, 3, 5, 9, 14, 24]
>>> del nums[4]
>>> nums
[1, 3, 5, 9, 24]
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Lists}

    List comprehensions, those shiny little things are GREAT.

    \begin{tcolorbox}
    \begin{minted}{python}
>>> nums = [1, 2, 5, 8, 14]
>>> [i * 2 for i in nums]
[2, 4, 10, 16, 28]
    \end{minted}
    \end{tcolorbox}

    \pause
    \begin{tcolorbox}
    \begin{minted}{python}
>>> [i // 2 for i in nums if not i % 2]
[1, 4, 7]
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Lists}

    By the way, strings can be used like lists.

    \begin{tcolorbox}
    \begin{minted}{python}
>>> filename = 'file.c'
>>> filename[-2:]
'.c'
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Lists}

    But strings are immutable

    \begin{tcolorbox}
    \begin{minted}{python}
>>> filename[-1] = 'h'
    \end{minted}
    \begin{minted}{py3tb}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
    \end{minted}
    \end{tcolorbox}

    \pause
    Just assign a new value:
    \begin{tcolorbox}
    \begin{minted}{python}
>>> filename = filename[:-1] + 'h'
>>> filename
'file.h'
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Lists}

    I said list comprehensions were great.

    \begin{tcolorbox}
    \begin{minted}[fontsize=\small]{python}
>>> sentence = 'And now for something completly different.'
>>> sentence.split()
['And', 'now', 'for', 'something', 'completly', 'different.']
>>> [word[0] for word in sentence.split()]
['A', 'n', 'f', 's', 'c', 'd']
>>> ''.join([word[0] for word in sentence.split()]).upper()
'ANFSCD'
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Dictionaries}

    You may know them as hashtables

    \begin{tcolorbox}
    \begin{minted}{python}
>>> ages = {'Terry Gilliam': 73, 'John Cleese': 75}
>>> ages['John Cleese']
75
>>> ages['Eric Idle'] = 71
>>> ages
{'Terry Gilliam': 73, 'Eric Idle': 71, 'John Cleese': 75}
>>> del ages['Terry Gilliam']
>>> ages
{'Eric Idle': 71, 'John Cleese': 75}
>>> list(ages.keys())
['Eric Idle', 'John Cleese']
    \end{minted}
    \end{tcolorbox}
\end{frame}

\subsection{Flow control}

\begin{frame}[fragile]{Functions}

    Let's forget the interpretor for a while.

    \begin{tcolorbox}
    \begin{minted}{python}
def say_hello():
    print('And now for something completely different')

say_hello()
    \end{minted}
    \end{tcolorbox}

Out:
    \begin{tcolorbox}
And now for something completely different
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Functions}

    \begin{tcolorbox}
    \begin{minted}{python}
def launch_holy_grenade(grenade):
    count = 3
    take_holy_pin_out(grenade)
    wait(count)
    throw(grenade)
    print('Boom!')

grenade = get_new_grenade()
launch_holy_grenade(grenade)
    \end{minted}
    \end{tcolorbox}

Out:
    \begin{tcolorbox}
Boom!
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Functions}

    Keyword arguments! (or optional arguments)

    \begin{tcolorbox}
    \begin{minted}{python}
def say(name, message='Hi {}!'):
    print(message.format(name))

say('Mr. E.R. Bradshaw of Napier Court')
say('Bradhsaw', message='{}, will you stand up please?')
    \end{minted}
    \end{tcolorbox}

Out:
    \begin{tcolorbox}
Hi Mr. E.R. Bradshaw of Napier Court!\\
Bradshaw, will you stand up please?
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Loops}

    The classic \emph{while}.

    \begin{tcolorbox}
    \begin{minted}{python}
>>> while i != 5:
...     i = random.randint(0,10)
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Loops}

    And the way cooler \emph{for}!

    \begin{tcolorbox}
    \begin{minted}{python}
>>> range(3)
[0, 1, 2]
>>> for i in range(3):
...     print(i, end=' ')
...
0 1 2
    \end{minted}
    \end{tcolorbox}

    \pause
    \begin{tcolorbox}
    \begin{minted}{python}
>>> for i in range(9, 0, -2):
...     print(i, end=' ')
...
9 7 5 3 1
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Loops}

    The \emph{for} loop can loop over any \emph{iterable} data type.

    \begin{tcolorbox}
    \begin{minted}{python}
>>> example_dict = {'first': 1, 'second': 2, 'third': 3}
>>> for key, value in example_dict.items():
...     print('key {} has value {}'.format(key, value))
...
key third has value 3
key first has value 1
key second has value 2
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Loops}
    \begin{tcolorbox}
    \begin{minted}[fontsize=\small]{python}
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> list(zip(questions, answers))
[('name', 'lancelot'), ('quest', 'the holy grail'),
('favorite color', 'blue')]
>>> for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
    \end{minted}
    \begin{verbatim}
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
    \end{verbatim}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Conditions}

    Readability, we like it.

    \begin{tcolorbox}
    \begin{minted}{python}
>>> if authorized:
...     print('Welcome!')
...
    \end{minted}
    \begin{verbatim}
Welcome!
    \end{verbatim}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Conditions}
    \begin{tcolorbox}
    \begin{minted}{python}
>>> def knock(age, has_id, has_license):
...     if age >= 18 and (has_id or has_license):
...         print("OK, you're cool enough")
...     else:
...         print("Nope.")
...
>>> knock(20, True, True)
    \end{minted}
OK, you're cool enough
    \begin{minted}{python}
>>> knock(40, False, True)
    \end{minted}
OK, you're cool enough
    \begin{minted}{python}
>>> knock(4, True, True)
    \end{minted}
Nope.
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Exception}
    \begin{tcolorbox}
    \begin{minted}{python}
>>> count = 3
>>> 'Then shalt thou count to ' + count + '.'
    \end{minted}
    \begin{minted}{py3tb}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Exception}
    \begin{tcolorbox}
    \begin{minted}{python}
>>> count = 3
>>> try:
...     'Then shalt thou count to ' + count + '.'
... except TypeError:
...     'NI!'
...
'NI!'
    \end{minted}
    \end{tcolorbox}
\end{frame}

\section{Modules}
\subsection{MANY exist}

\begin{frame}[fragile]{argparse}

    \begin{quote}
    Parser for command-line options, arguments and sub-commands
    \end{quote}

    \begin{overprint}
    \onslide<1>
    myprogram.py:
    \begin{tcolorbox}
    \begin{minted}[fontsize=\small]{python}
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--foo', help='foo help')
args = parser.parse_args()
print('You entered "{}".'.format(args.foo))
    \end{minted}
    \end{tcolorbox}

    \onslide<2>
    In a shell:
    \begin{tcolorbox}
        \begin{Verbatim}[fontsize=\small]
$ python myprogram.py --help
usage: myprogram.py [-h] [--foo FOO]

optional arguments:
 -h, --help  show this help message and exit
  --foo FOO   foo help

$ python myprogram.py --foo something
You entered "something".
        \end{Verbatim}
    \end{tcolorbox}
    \end{overprint}
\end{frame}

\begin{frame}[fragile]{shutil}

    \begin{quote}
    High-level file operations
    \end{quote}

    \begin{tcolorbox}
    \begin{minted}{python}
import shutil
shutil.copy('Makefile', 'src/Makefile')
shutil.chown('Makefile', user='dettorer', group='users')
print(shutil.disk_usage('/home'))

archive_name = 'sources'
root_dir = 'src'
make_archive(archive_name, 'gztar', root_dir)
# Creates sources.tar.gz
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{subprocess}

    \begin{quote}
    Subprocesse management
    \end{quote}

    \begin{tcolorbox}
    \begin{minted}{python}
import subprocess
subprocess.call(['git', 'pull', '--rebase'])

out = subprocess.getoutput(['ls'])
file_count = len(out.split('\n'))

out = subprocess.getoutput('wc -l /var/log/Xorg.0.log')
line_count = int(out.split()[0])
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{sh}

    \begin{quote}
        A full-fledged subprocess interface for Python that allows you to call any program as if it were a function.
    \end{quote}

    Same, but with more MAGIC.\\
    (but it's an pypi module you have to install)\\
    Example: pip install sh

    \begin{tcolorbox}
    \begin{minted}{python}
import sh
sh.ls('-l')
print(sh.sort(sh.du(sh.glob("*"), "-s"), "-rn"))
sh.git.pull()
sh.make(_out='make_output.txt', _err='make_errors.txt')
errors = sh.cat('make_errors.txt')
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{os}

    \begin{quote}
    Miscellaneous operating system interfaces
    \end{quote}

    \begin{tcolorbox}
    \begin{minted}{python}
>>> import os
>>> os.name
'posix'
>>> os.getcwd()
'/home/dettorer/work/temp'
>>> os.getlogin()
'dettorer'
>>> os.path.join('src', 'dir1', 'subdir')
'src/dir1/subdir'
>>> os.access('a.out', os.X_OK)
True
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{datetime}

    \begin{quote}
    Basic date and time types.
    \end{quote}
    What? \emph{"Basic"}?

    \begin{tcolorbox}
    \begin{minted}{python}
>>> from datetime import datetime, delta
>>> now = datetime.now()
>>> print(now)
2014-11-07 23:51:29.972649
>>> print(now - timedelta(minutes=55))
2014-11-07 22:56:29.972649
>>> start = datetime(2014, 11, 1)
>>> print(now - start)
6 days, 23:51:29.972649
    \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{And more!}

    Look them up, they are all pretty neat!

    \begin{itemize}
        \item import re -- Regular expressions
        \item import unittest -- Unit testing
        \item import logging -- Logging facility
        \item import itertools -- Advanced iterators
        \item import functools -- Advanced functions
        \item import difflib -- Compare files and more
        \item import glob -- Globbing
        \item import multiprocessing -- Multiprocessing
        \item import numpy, scipy, matplotlib, scikit-learn -- SCIENCE
        \item import http -- try 'python -m http.server'
    \end{itemize}
\end{frame}

\subsection{Write your own ones!}

\begin{frame}[fragile]{Write a module}

    We already did it:

    \begin{overprint}
    \onslide<1>
    my\_module.py:
    \begin{tcolorbox}
        \begin{minted}{python}
def say(name, message='Hi {}!'):
    print(message.format(name))

def launch_holy_grenade():
    count = 3
    take_holy_pin_out()
    wait(count)
    throw()
    print('Boom!')
        \end{minted}
    \end{tcolorbox}

    \onslide<2>
    interpretor (in the same folder):
    \begin{tcolorbox}
        \begin{minted}{python}
>>> import my_module
>>> my_module.launch_holy_grenade()
        \end{minted}
Boom!
        \begin{minted}{python}
>>> my_module.say('Bradhsaw', message='Hello {}!)
        \end{minted}
Hello Bradshaw!
    \end{tcolorbox}
    \end{overprint}
\end{frame}

\begin{frame}[fragile]{Warning!}

    Any toplevel code is executed at \emph{import}

    my\_module.py:
    \begin{tcolorbox}
        \begin{minted}{python}
def say(name, message='Hi {}!'):
    print(message.format(name))

say('test', message='this is a {}')
        \end{minted}
    \end{tcolorbox}

    \begin{tcolorbox}
        \begin{minted}{python}
>>> import my_module
this is a test
>>> my_module.say('Chicken')
        \end{minted}
Hi Chicken!
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Warning!}

    Here's how to create a "main" function

    my\_module.py:
    \begin{tcolorbox}
        \begin{minted}[fontsize=\small]{python}
def say(name, message='Hi {}!'):
    print(message.format(name))

if __name__ == '__main__':
    say('test', message='this is a {}')
        \end{minted}
    \end{tcolorbox}

    \begin{tcolorbox}
        \begin{minted}[fontsize=\small]{python}
>>> import my_module
>>> my_module.say('Chicken')
        \end{minted}
Hi Chicken!
    \end{tcolorbox}

    \begin{tcolorbox}
        \begin{Verbatim}[fontsize=\small]
$ python my_module.py
this is a test
        \end{Verbatim}
    \end{tcolorbox}
\end{frame}

\section{The end}
\subsection{A bit further}

\begin{frame}[fragile]{OOP}
    \begin{tcolorbox}
        \begin{minted}{python}
>>> class Bag:
...     def __init__(self):
...         self.data = []
...     def add(self, x):
...         self.data.append(x)
...     def look_inside(self):
...         print(self.data)

>>> my_bag = Bag()
>>> my_bag.add('car')
>>> my_bag.add('house')
>>> my_bag.look_inside()
['car', 'house']
        \end{minted}
    \end{tcolorbox}
\end{frame}

\begin{frame}[fragile]{Decorators}
    \begin{overprint}
    \onslide<1>
    \begin{tcolorbox}
        \begin{minted}{python}
>>> def twice(some_function):
...    def wrapper():
...        some_function()
...        some_function()
...    return wrapper
...
>>> @twice
... def hello():
...     print('hello')
...
>>> hello()
hello
hello
        \end{minted}
    \end{tcolorbox}

    \onslide<2>
    \begin{tcolorbox}
        \begin{minted}{python}
>>> def twice(some_function):
...    def wrapper(*args, **kwargs):
...        some_function(*args, **kwargs)
...        some_function(*args, **kwargs)
...    return wrapper
...
>>> @twice
... def hello(name):
...     print('hello, {}'.format(name))
...
>>> hello('world')
hello, world
hello, world
        \end{minted}
    \end{tcolorbox}

    But we'll see that an other time...

    \end{overprint}
\end{frame}

\subsection{And now for something completely different}

\begin{frame}{CONCLUSION}
    \begin{itemize}
        \item The documentation is awesome: \myurl{https://docs.python.org}
        \item For a good coding style: PEP8
        \item A great book: Python Cookbook
        \item A debugger: pdb!
        \item \emph{Lots} of awsome modules: \myurl{https://pypi.python.org}
        \item A wonderful interactive interpretor: IPython
    \end{itemize}
\end{frame}

\begin{frame}{QUESTION TIME}

    Question? Remarks? Worries? Things unclear?

\end{frame}

\begin{frame}{Bye then you marvellous audience!}

    GOOD NIGHT!

\end{frame}

\end{document}
